package jokrapp.boomerang;

import android.app.Activity;
<<<<<<< HEAD
import android.hardware.Camera;
import android.os.Bundle;
import android.app.Fragment;
=======
import android.content.Context;
import android.content.SharedPreferences;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.SurfaceTexture;
import android.graphics.drawable.Drawable;
import android.hardware.Camera;
import android.media.ExifInterface;
import android.os.AsyncTask;
import android.os.Bundle;
import android.app.Fragment;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Looper;
import android.os.Message;
import android.os.Messenger;
import android.os.RemoteException;
import android.preference.PreferenceManager;
import android.util.AttributeSet;
>>>>>>> a0109ac8d100d83e0d39841cc15523240ddbfb3f
import android.util.Log;
import android.view.GestureDetector;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
<<<<<<< HEAD
=======
import android.widget.FrameLayout;
import android.widget.ImageButton;
import android.widget.Toast;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.ref.WeakReference;
import java.text.SimpleDateFormat;
import java.util.Date;
>>>>>>> a0109ac8d100d83e0d39841cc15523240ddbfb3f
import java.util.List;


/**
 * Author/Copyright John C. Quinn All Rights Reserved
 * Date last modified: 2015-06-17
 *
 *
 * A simple {@link Fragment} subclass.
 * Activities that contain this fragment must implement the
 * {@link CameraFragment.OnCameraFragmentInteractionListener} interface
 * to handle interaction events.
 * Use the {@link CameraFragment#newInstance} factory method to
 * create an instance of this fragment.
 *
 */
<<<<<<< HEAD
public class CameraFragment extends Fragment implements GestureDetector.OnDoubleTapListener {
=======
public class CameraFragment extends Fragment {
>>>>>>> a0109ac8d100d83e0d39841cc15523240ddbfb3f
    private static final boolean VERBOSE = true;
    private static final String TAG = "CameraFragment";

    private GestureDetector gestureDetector;

    private static Camera.Size imageDimensons; //dimensions of the image to save


    //the list of cameras to be displayed
    private int[] cameraList;

    private static final int CAMERA_POSITION_BACK = 0;
    private static final int CAMERA_POSITION_FRONT = 1;

    private static final String PREVIEW_WIDTH_FRONT = "pwidth";
    private static final String PREVIEW_HEIGHT_FRONT = "pheight";


    private static final String PREVIEW_WIDTH_BACK = "nwidth";
    private static final String PREVIEW_HEIGHT_BACK = "nheight";



    //references the front facing camera
    private static int currentCamera = CAMERA_POSITION_BACK;

<<<<<<< HEAD
    private SurfaceView mPreview;
=======
    private CameraSurfaceView mPreview;
>>>>>>> a0109ac8d100d83e0d39841cc15523240ddbfb3f

    private static boolean isConnected = false;

    private static boolean isPreview = true;


    private OnCameraFragmentInteractionListener mListener;

/***************************************************************************************************
 * LIFECYCLE METHODS
 */
 /**
  * Use this factory method to create a new instance of
  * this fragment using the provided parameters.
  *
  * @return A new instance of fragment CameraFragment.
  */
  // TODO: Rename and change types and number of parameters
 public static CameraFragment newInstance() {
      CameraFragment fragment = new CameraFragment();
      Bundle args = new Bundle();
      fragment.setArguments(args);
      return fragment;
    }

    public CameraFragment() {
        // Required empty public constructor
    }

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);
        try {
            mListener = (OnCameraFragmentInteractionListener) activity;
        } catch (ClassCastException e) {
            throw new ClassCastException(activity.toString()
                    + " must implement OnFragmentInteractionListener");
        }

    }

    @Override
    public void onDetach() {
        super.onDetach();
        mListener = null;

    }



    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        if (savedInstanceState != null) {
            Log.d(TAG, "restoring state...");
        }
        //connectCamera();
<<<<<<< HEAD

        gestureDetector = new GestureDetector(getActivity(),new MyGestureListener());
    }

    class MyGestureListener extends GestureDetector.SimpleOnGestureListener {
        private static final String TAG = "Gestures";

        @Override
        public boolean onDoubleTapEvent(MotionEvent e) {

            if (isPreview) {
                mListener.sendMsgSwitchCamera();
            } else {

            }
            return super.onDoubleTapEvent(e);
        }
=======

        //mPreview = new CameraPreview(this.getActivity(), mCamera);

        //cameraList = new int[Camera.getNumberOfCameras()];
        //for (int i = 0; i < cameraList.length; i++) {
        //    cameraList[i] = i;
        //}
>>>>>>> a0109ac8d100d83e0d39841cc15523240ddbfb3f

    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        if (VERBOSE) {
            Log.v(TAG, "saving state...");
        }
    }

    @Override
    public void onPause() {
        super.onPause();
        if (VERBOSE) {
            Log.v(TAG, "enter onPause...");
        }

        if (VERBOSE) {
            Log.v(TAG, "exit onPause...");
        }
    }

    @Override
    public void onResume() {
        super.onResume();
        if (VERBOSE) {
            Log.v(TAG, "enter onResume...");
        }


        if (VERBOSE) {
            Log.v(TAG, "exit onResume...");
        }
    }

    @Override
    public void onStart() {
        super.onStart();
        if (VERBOSE) {
            Log.v(TAG, "enter onStart...");
        }

        mListener.sendMsgStartPreview();

        if (VERBOSE) {
            Log.v(TAG, "exit onStart...");
        }
    }

    @Override
    public void onStop() {
        super.onStop();
        if (VERBOSE) {
            Log.v(TAG, "enter onStop...");
        }

        mListener.sendMsgStopPreview();

        if (VERBOSE) {
            Log.v(TAG, "exit onStop...");
        }
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        if (VERBOSE) {
            Log.v(TAG, "enter onDestroy...");
        }
        if (VERBOSE) {
            Log.v(TAG, "exit onDestroy...");
        }

    }

    /**
     * method 'disconnectCamera'
     *
     *
     */
    public void disconnectCamera() {
        if (VERBOSE) {
            Log.v(TAG, "enter disconnectCamera...");
        }

        if (isConnected) {
            Log.d(TAG, "disconnecting camera...");
            //mCamera.release();
            //mCamera = null;
            //isConnected = false;
        }


        if (VERBOSE) {
            Log.v(TAG, "exit disconnectCamera...");
        }
    }


    //public void startPreview() {
    //    if (isPreview && mCamera != null) {
    //        Log.d(TAG, "starting preview...");
            //mCamera.startPreview();
    //    }
    //}

    public void stopPreview() {
        if(isPreview) {
            Log.d(TAG, "stopping preview...");
            //mCamera.stopPreview();
            //mPreview = null;
        }
    }

    /**
     * method 'onCreateView'
     *
     * lifecycle method called when the view is beginning to be created
     *
     * @param inflater the inflater which is creating the view
     * @param container the container in which the view is held
     * @param savedInstanceState if there is a savedinstanceState, data will be stored here
     * @return the view to be created
     */
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        // Inflate the layout for this fragment
        if (VERBOSE) {
            Log.v(TAG, "enter onCreateView...");
        }

<<<<<<< HEAD
        container.setOnTouchListener(new View.OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                gestureDetector.onTouchEvent(event);
                return false;
            }
        });
=======
>>>>>>> a0109ac8d100d83e0d39841cc15523240ddbfb3f
        //creates the camera preview, adds to
        return inflater.inflate(R.layout.fragment_camera, container, false);
    }


    /**
     * method 'onViewCreated'
     *
     * Lifecycle method- called when the current view is created
     *
     * @param view current view that was created
     * @param savedInstanceState a savedinstancestate, if any
     */
    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        if (VERBOSE) {
            Log.v(TAG, "enter onViewCreated...");
        }


        if (savedInstanceState != null) {
            if (VERBOSE) {
                Log.v(TAG, "onViewCreated had a saved instance.");
            }
        }

        final Button switchButton = (Button) view.findViewById(R.id.switch_camera);

        switchButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                mListener.sendMsgSwitchCamera();
            }
        });


        final Button captureButton = (Button) view.findViewById(R.id.button_capture);
        //creates an onClickListener for the capture button
        captureButton.setOnClickListener(
                new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        // get an image from the camera
                        if (isConnected) {

                            //capture the photo
                            try {
                                mListener.sendMsgTakePicture();
                            } catch (Exception e) {
                                Log.e(TAG,"takePicture failed",e);
                            }

                        } else {
                            Log.e(TAG, "the camera was not connected!");
                        }
                    }
                }
        );

        captureButton.bringToFront();

<<<<<<< HEAD

        mPreview = (SurfaceView)view.findViewById(R.id.cameraSurfaceView);

        //mListener.sendMsgStartPreview();
        /*
        try {
            Messenger activityMessenger = ((MainActivity)getActivity()).cameraMessenger;
            Message msg = Message.obtain(null, MSG_SET_PREVIEW);
            msg.replyTo = activityMessenger;
            activityMessenger.send(msg);

        } catch (RemoteException e) {
            Log.e(TAG, "error sending message to connect camera");
        }*/


        if (VERBOSE) {
            Log.v(TAG, "exit onViewCreated...");
        }
=======
>>>>>>> a0109ac8d100d83e0d39841cc15523240ddbfb3f

        mPreview = (CameraSurfaceView)view.findViewById(R.id.cameraSurfaceView);

<<<<<<< HEAD


    @Override
    public boolean onSingleTapConfirmed(MotionEvent e) {
        if (VERBOSE) {
            Log.d(TAG,e.toString());
        }
        return false;
    }

    @Override
    public boolean onDoubleTap(MotionEvent e) {
        if (VERBOSE) {
            Log.d(TAG,e.toString());
        }
        return false;
    }

    @Override
    public boolean onDoubleTapEvent(MotionEvent e) {
        if (VERBOSE) {
            Log.d(TAG,e.toString());
        }
        return false;
    }

    public SurfaceHolder getPreviewHolder() {
        return mPreview.getHolder();
=======
        //mListener.sendMsgStartPreview();
        /*
        try {
            Messenger activityMessenger = ((MainActivity)getActivity()).cameraMessenger;
            Message msg = Message.obtain(null, MSG_SET_PREVIEW);
            msg.replyTo = activityMessenger;
            activityMessenger.send(msg);

        } catch (RemoteException e) {
            Log.e(TAG, "error sending message to connect camera");
        }*/


        if (VERBOSE) {
            Log.v(TAG, "exit onViewCreated...");
        }

    }

    public SurfaceHolder getPreviewHolder() {
        return mPreview.getmHolder();
>>>>>>> a0109ac8d100d83e0d39841cc15523240ddbfb3f
    }

    /***********************************************************************************************
     *
     *   CAMERA MANAGEMENT
     *
     */
    /**
     * Interface to receive picture callback from the capturebutton
     *
     * sets a new click listener for the confirm button, which saves the file
     */


        /**
         * method 'onPictureTaken'
         *
         * the method that is called when a picture is taken
         *
         * @param Success whether or not the image saving was a success
         */
        public void onPictureTaken(int Success) {
            if (VERBOSE) {
                Log.v(TAG, "enter onPictureTaken... ");
            }

            isPreview = false;

            mListener.toggleScrolling();

            final Button cancelButton = (Button) getActivity().findViewById(R.id.button_cancel);
            final Button confirmButton = (Button) getActivity().findViewById(R.id.button_confirm);
            final Button captureButton = (Button) getActivity().findViewById(R.id.button_capture);
            final Button switchButton = (Button) getActivity().findViewById(R.id.switch_camera);

            cancelButton.bringToFront();
            confirmButton.bringToFront();

            captureButton.setVisibility(View.INVISIBLE);
            switchButton.setVisibility(View.INVISIBLE);

            cancelButton.setVisibility(View.VISIBLE);
            confirmButton.setVisibility(View.VISIBLE);

            confirmButton.setOnClickListener((new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    if (VERBOSE) {
                        Log.v(TAG, "enter confirmButton onClick... ");
                    }


                    mListener.sendMsgSaveImage();
                    mListener.sendMsgStartPreview();

                    isPreview = true;

                    mListener.toggleScrolling();

                    captureButton.setVisibility(View.VISIBLE);
                    switchButton.setVisibility(View.VISIBLE);

                    cancelButton.setVisibility(View.INVISIBLE);
                    confirmButton.setVisibility(View.INVISIBLE);

                    if (VERBOSE) {
                        Log.v(TAG, "exit confirmButton onClick... ");
                    }
                }

            }));

            cancelButton.setOnClickListener((new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    if (VERBOSE) {
                        Log.v(TAG, "enter cancelButton onClick... ");
                    }

                    isPreview = true;
                    mListener.sendMsgStartPreview();
                    mListener.toggleScrolling();

                    captureButton.setVisibility(View.VISIBLE);
                    switchButton.setVisibility(View.VISIBLE);

                    cancelButton.setVisibility(View.INVISIBLE);
                    confirmButton.setVisibility(View.INVISIBLE);

                    if (VERBOSE) {
                        Log.v(TAG, "exit cancelButton onClick... ");
                    }
                }
            }));


            if (VERBOSE) {
                Log.v(TAG, "exit onPictureTaken...");
            }
        }






    /**
     * Communication back to the activity
     *
     */
    /**
     * currently, this method passed the file path to a function in the MainActivity
     * that loads the bitmap
     */
    public interface OnCameraFragmentInteractionListener {
        void onImageSaved(String filePath);
        void toggleScrolling();
        void sendMsgStartPreview();
        void sendMsgStopPreview();
        void sendMsgTakePicture();
        void sendMsgSaveImage();
        void sendMsgSwitchCamera();
<<<<<<< HEAD
=======
    }


    public static final int MSG_CONNECT_CAMERA = 0;
    public static final int MSG_DISCONNECT_CAMERA = 1;
    public static final int MSG_SET_PREVIEW = 2;
    public static final int MSG_START_PREVIEW = 3;
    public static final int MSG_FRAGMENT_DESTROYED = 4;



    /**
     * method 'connectCamera()'
     *
     * convenience method to simplify for all the different times we will be connecting
     *
     * attempts to Connect to the camera for use in this fragment
     * manages status and log data
     *
     * utilizes getCameraInstance to try the actual connection
     *//*
    public void connectCamera() {
        Log.d(TAG, "enter connectCamera...");
        if (!isConnected) {
            Log.d(TAG, "camera was disconnected, connecting camera...");

            mCamera = getCameraInstance();
            if (mCamera != null) {
                Log.d(TAG, "camera successfully connected...");
            } else {
                Log.e(TAG, "camera did not connect, quitting");
                return;
            }


            if (isPreview) {
                //if (mPreview== null) {
                    Log.d(TAG,"mPreview was null");
                    mPreview = new CameraPreview(this.getActivity(), mCamera);

                    FrameLayout preview = (FrameLayout) getActivity().findViewById(R.id.camera_root);
                    if (preview != null) {
                        preview.addView(mPreview);
                    }
                }
                Log.d(TAG, "camera was in preview mode");
                startPreview();
            } else {
                Log.d(TAG, "camera was not in preview mode");
            }


            if (mCamera != null) {


                  Log.d(TAG, "decide what image resolution to use"); //todo do this for more devices

                Camera.Parameters parameters = mCamera.getParameters();
                List<Camera.Size> sizes = parameters.getSupportedPictureSizes();

                if (VERBOSE) {
                    Log.v(TAG, "viable image sizes: ");
                    for(int i = 0; i < sizes.size(); i++) {
                        Log.d(" ", " " + sizes.get(i).width + sizes.get(i).height);
                    }
                }

                if (currentCamera == 0) {
                    imageDimensons = getOptimalCameraResolution(mCamera);
                    parameters.setPictureSize(imageDimensons.width, imageDimensons.height);
                    parameters.set("orientation", "portrait");
                    parameters.setRotation(90);
                    parameters.set("rotation", 90);
                    Log.d(TAG, "setting parameters for mCamera...");

                    mCamera.setParameters(parameters);

                    if (mPreview != null && mPreview.getCamera() != null) {
                        mPreview.updatePreview();
                    }
                } else {
                    imageDimensons = getOptimalCameraResolution(mCamera);
                    parameters.setPictureSize(imageDimensons.width, imageDimensons.height);
                    parameters.set("orientation", "portrait");
                    parameters.set("rotation", 90);
                    parameters.setRotation(90);
                    Log.d(TAG, "setting parameters for mCamera...");
                    mCamera.setParameters(parameters);

                    if (isPreview){
                        if (mPreview.getCamera() != mCamera) {
                            mPreview.updatePreview();
                        }
                    }
                }
            }

        }

        Log.d(TAG, "exit connectCamera...");
    }

    private Camera.Size getOptimalCameraResolution(Camera camera) {
        SharedPreferences p = PreferenceManager.getDefaultSharedPreferences(getActivity());
        int optimalWidth= p.getInt(RESOLUTION_WIDTH, -1);
        int optimalHeight= p.getInt(RESOLUTION_HEIGHT, -1);
        if (optimalWidth != -1 || optimalHeight != -1) {
            return camera.new Size(optimalWidth, optimalHeight);
        } else {
            Camera.Size size =calculateOptimalCameraResolution(camera);
            p.edit().putInt(RESOLUTION_WIDTH,size.width).apply();
            p.edit().putInt(RESOLUTION_HEIGHT,size.height).apply();
            return size;
        }
    }*/


    /**
     * static method 'calculateOptimalResolution'
     *
     * tests available resolutions of the provided camera, first checks if it supports
     * the optimal resolution. Should that resolution not be available, it then attempts to
     * calculate the resolution which is closest to the optimal.
     *
     * Uses the distance formula in {@link SQLiteDbHelper}
     *
     * @param camera camera to test resolutions from
     * @return best resolution available
     */
    private static Camera.Size calculateOptimalCameraResolution(Camera camera) {
        if (VERBOSE) {
            Log.v(TAG,"enter calculateOptimalResolution...");
        }

        Camera.Parameters parameters = camera.getParameters();
           List<Camera.Size> sizes = parameters.getSupportedPictureSizes();

        if (VERBOSE) {
            Log.v(TAG, "viable image sizes: ");
            for(int i = 0; i < sizes.size(); i++) {
                Log.v(" ", " " + sizes.get(i).width + sizes.get(i).height);
            }
        }


        //for each size, first, do they have it? - try each size
        for (Camera.Size s : sizes) {
            if (s.width == Constants.IDEAL_WIDTH) {
                if (s.height == Constants.IDEAL_HEIGHT) {
                    //found it
                    Log.d(TAG,"perfect resolution found! " + s.width + ", " + s.height);
                    return s;
                }
            }
        }

        //guess it failed, calculation time
        Log.d(TAG,"perfect resolution not found.");

        int closestDistance = 9000;
        Camera.Size closestSize = sizes.get(sizes.size()-1);

        for (Camera.Size s : sizes) {
            Double currentDistance = SQLiteDbHelper.distanceFormula(s.width,s.height,
                    Constants.IDEAL_WIDTH,Constants.IDEAL_HEIGHT);

            if (currentDistance < closestDistance) {
                closestDistance = currentDistance.intValue();
                closestSize = s;

            }
        }
        Log.d(TAG,"closestSize found is: " + closestSize.width + ", " + closestSize.height);

        if (VERBOSE) {
            Log.v(TAG, "exit calculateOptimalResolution...");
        }
        return closestSize;
>>>>>>> a0109ac8d100d83e0d39841cc15523240ddbfb3f
    }


    /** A safe way to get an instance of the Camera object. */
    public static Camera getCameraInstance(int whichCamera){
        Camera c = null;
        try {
            c = Camera.open(whichCamera); // attempt to get a Camera instance
        }
        catch (Exception e){
            // Camera is not available (in use or does not exist)
            Log.d(TAG,"Error opening camera",e);
        }
        if (c != null) {
            isConnected = true;
        }

        return c; // returns null if camera is unavailable
    }

<<<<<<< HEAD
=======

    /** A safe way to get an instance of the Camera object. */
    public static Camera getCameraInstance(int whichCamera){
        Camera c = null;
        try {
            c = Camera.open(whichCamera); // attempt to get a Camera instance
        }
        catch (Exception e){
            // Camera is not available (in use or does not exist)
            Log.d(TAG,"Error opening camera",e);
        }
        if (c != null) {
            isConnected = true;
        }

        return c; // returns null if camera is unavailable
    }

>>>>>>> a0109ac8d100d83e0d39841cc15523240ddbfb3f

    /**
     * method 'getOptionalPreviewSize'
     *
     * finds the best preview size to aspect ratio and returns the size
     *
     * @param sizes camera sizes available
     * @param w width to aim for
     * @param h height to aim for
     * @return the optinal Camera.size for the preview
     */
    private static Camera.Size calculateOptimalPreviewSize(List<Camera.Size> sizes, int w, int h) {
        if (VERBOSE) {
            Log.v(TAG, "enter calculateOptimalPreviewSize...");
        }
<<<<<<< HEAD

            final double ASPECT_TOLERANCE = 0.1;
            double targetRatio = (double) h / w;

            if (sizes == null) return null;

            Camera.Size optimalSize = null;
            double minDiff = Double.MAX_VALUE;

=======

            final double ASPECT_TOLERANCE = 0.1;
            double targetRatio = (double) h / w;

            if (sizes == null) return null;

            Camera.Size optimalSize = null;
            double minDiff = Double.MAX_VALUE;

>>>>>>> a0109ac8d100d83e0d39841cc15523240ddbfb3f
            int targetHeight = h;

            for (Camera.Size size : sizes) {
                double ratio = (double) size.width / size.height;
                if (Math.abs(ratio - targetRatio) > ASPECT_TOLERANCE) continue;
                if (Math.abs(size.height - targetHeight) < minDiff) {
                    optimalSize = size;
                    minDiff = Math.abs(size.height - targetHeight);
                }
            }
<<<<<<< HEAD

            if (optimalSize == null) {
                minDiff = Double.MAX_VALUE;
                for (Camera.Size size : sizes) {
                    if (Math.abs(size.height - targetHeight) < minDiff) {
                        optimalSize = size;
                        minDiff = Math.abs(size.height - targetHeight);
=======

            if (optimalSize == null) {
                minDiff = Double.MAX_VALUE;
                for (Camera.Size size : sizes) {
                    if (Math.abs(size.height - targetHeight) < minDiff) {
                        optimalSize = size;
                        minDiff = Math.abs(size.height - targetHeight);
                    }
                }
            }
        if (VERBOSE) {
            Log.v(TAG,"exit calculateOptimalPreviewSize...");
        }

        return optimalSize;
    }


    /**
     * method 'getOptionalPreviewSize'
     *
     * grabs the best preview size from shared preferences, or calculates it through
     * calculateOptimalPreviewSize
     *
     * @param camera the camera with which to measure
     * @param w width to aim for
     * @param h height to aim for
     * @return the optinal Camera.size for the preview
     */
    private Camera.Size getOptimalPreviewSize(Camera camera, int w, int h) {
        if (VERBOSE) {
            Log.v(TAG,"enter getOptimalPreviewSize...");
        }
        SharedPreferences p = PreferenceManager.getDefaultSharedPreferences(getActivity());


        Camera.Size optimalSize;

        int width;
        int height;

        if (currentCamera  == CAMERA_POSITION_FRONT) {
            width = p.getInt(PREVIEW_WIDTH_FRONT, -1);
            height = p.getInt(PREVIEW_HEIGHT_FRONT, -1);


            if (width == -1) {//preview size has yet to be measured
                Log.d(TAG,"Measuring front camera preview dimensions");

                optimalSize = calculateOptimalPreviewSize(camera.getParameters().getSupportedPreviewSizes(),w,h);

                p.edit().putInt(PREVIEW_WIDTH_FRONT, optimalSize.width).apply();
                p.edit().putInt(PREVIEW_HEIGHT_FRONT, optimalSize.height).apply();
            } else {
                optimalSize = camera.new Size(width,height);
            }

        } else {

            width = p.getInt(PREVIEW_WIDTH_BACK, -1);
            height = p.getInt(PREVIEW_HEIGHT_BACK, -1);

            if (width == -1) {//preview size has yet to be measured
                Log.d(TAG,"Measuring back camera preview dimensions");

                optimalSize = calculateOptimalPreviewSize(camera.getParameters().getSupportedPreviewSizes(),w,h);

                p.edit().putInt(PREVIEW_WIDTH_BACK, optimalSize.width).apply();
                p.edit().putInt(PREVIEW_HEIGHT_BACK, optimalSize.height).apply();

            } else {
                optimalSize = camera.new Size(width,height);
            }
        }

        if (VERBOSE) {
            Log.v(TAG,"exit getOptimalPreviewSize...");
        }

        return optimalSize;
    }






    /***********************************************************************************************
     *
     * class 'CameraPreview'
     *
     * custom SurfaceView that displays the camera preview
     */
    public class CameraPreview extends SurfaceView implements SurfaceHolder.Callback {
        private SurfaceHolder mHolder;
        private Camera camera;
        private final String TAG = "CameraPreview";
        private Camera.Size mPreviewSize;
        private GestureDetector gestureDetector;


        public CameraPreview(Context context, Camera camera) {
            super(context);

            Log.d(TAG, "has been created");

            this.camera = camera;

            // Install a SurfaceHolder.Callback so we get notified when the
            // underlying surface is created and destroyed.
            mHolder = getHolder();
            mHolder.addCallback(this);

            gestureDetector = new GestureDetector(context, new GestureListener());
        }

        public Camera getCamera() {
            return camera;
        }

        /*
        @Override
        protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
            if (VERBOSE) {
                Log.v(TAG, "entering onMeasure...");
            }

            final int width = resolveSize(getSuggestedMinimumWidth(), widthMeasureSpec);
            final int height = resolveSize(getSuggestedMinimumHeight(), heightMeasureSpec);
            setMeasuredDimension(width, height);

            mPreviewSize = getOptimalPreviewSize(camera, width, height);


            if (VERBOSE) {
                Log.v(TAG, "exiting onMeasure...");
            }
        }*/

        public void surfaceCreated(SurfaceHolder holder) {
            if (VERBOSE) {
                Log.v(TAG, "entering surfaceCreated...");
            }

            // The Surface has been created, now tell the camera where to draw the preview
            try {
                if (camera != null) {

                    if (isConnected) {

                            camera.setDisplayOrientation(90);

                            camera.setPreviewDisplay(holder);
                            camera.startPreview();
>>>>>>> a0109ac8d100d83e0d39841cc15523240ddbfb3f
                    }
                }
            }
<<<<<<< HEAD
        if (VERBOSE) {
            Log.v(TAG,"exit calculateOptimalPreviewSize...");
        }

        return optimalSize;
    }


=======

            // stop preview before making changes
            try {
                camera.stopPreview();
            } catch (Exception e) {
                // ignore: tried to stop a non-existent preview
            }

            // set preview size and make any resize, rotate or
            // reformatting changes here

            // start preview with new settings
            try {

                camera.setPreviewDisplay(mHolder);
                Camera.Parameters parameters = camera.getParameters();


                parameters.setPreviewSize(mPreviewSize.width, mPreviewSize.height);
                parameters.set("orientation", "portrait");
                parameters.setRotation(90);
                parameters.set("rotation", 90);
                camera.setParameters(parameters);
                camera.startPreview();
                isPreview = true;


            } catch (Exception e) {
                Log.e(TAG, "Error error starting camera preview", e);
            }

            if (VERBOSE) {
                Log.d(TAG, "exit surfaceChanged...");
            }
        }

        public void updatePreview() {
            if (mPreviewSize != null) {

            // stop preview before making changes
                //camera = mCamera;
                camera.setDisplayOrientation(90);
                Camera.Parameters parameters = camera.getParameters();
                parameters.setPreviewSize(mPreviewSize.width, mPreviewSize.height);
                parameters.set("orientation","portrait");
            try {
                camera.setParameters(parameters);
                camera.setPreviewDisplay(mHolder);
                camera.startPreview();
                isPreview = true;
            } catch (Exception e) {
                Log.e(TAG, "Error error starting camera preview", e);
            }

            }
        }


        @Override
        public boolean onTouchEvent(MotionEvent e)
        {
                return gestureDetector.onTouchEvent(e);
        }


        private class GestureListener extends GestureDetector.SimpleOnGestureListener {

            @Override
            public boolean onDown(MotionEvent e) {
                return true;
            }
            // event when double tap occurs
            @Override
            public boolean onDoubleTap(MotionEvent e) {
                if (VERBOSE) {
                    Log.d(TAG, "DoubleTap detected, calling switchCamera()...");
                }
                if (isPreview) {
                    // switchCamera();
                }
                return true;
            }
        }


    }


>>>>>>> a0109ac8d100d83e0d39841cc15523240ddbfb3f
}
