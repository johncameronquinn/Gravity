package jokrapp.boomerang;

import android.app.AlertDialog;
import android.app.FragmentManager;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.SharedPreferences;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Matrix;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.hardware.Camera;
import android.location.LocationManager;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.IBinder;
import android.os.Message;
import android.os.Messenger;
import android.os.RemoteException;
import android.preference.PreferenceManager;
import android.provider.Settings;
import android.app.Fragment;
import android.support.v13.app.FragmentStatePagerAdapter;
import android.support.v7.app.AppCompatActivity;
import android.util.AttributeSet;
import android.util.Log;
import android.view.GestureDetector;
import android.view.MotionEvent;
import android.view.View;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.TextView;
import android.widget.Toast;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.ref.WeakReference;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Locale;

/**
 * Author/Copyright John C. Quinn All Rights Reserved.
 * created: 3-26-2015
 * date last modified: 2015-06-17
 *
 * this is the main activity for the app Proxi
 *
 * there is only one activity, and all the other features are managed as fragments
 */
public class MainActivity extends AppCompatActivity implements LocalFragment.localFragmentListener,
<<<<<<< HEAD
        CameraFragment.OnCameraFragmentInteractionListener {
=======
        CameraFragment.OnCameraFragmentInteractionListener, GestureDetector.OnDoubleTapListener {
>>>>>>> a0109ac8d100d83e0d39841cc15523240ddbfb3f
    private static String TAG = "MainActivity";
    private static final boolean VERBOSE = true;

    private static String imageDir;

    //UI
    private static CustomViewPager mPager;
    private static MainAdapter mAdapter;


    /** FRAGMENT MANAGEMENT
     */
    private static final int MESSAGE_LIST_POSITION = 0;
    private static final int LOCAL_LIST_POSITION = 1;
    private static final int CAMERA_LIST_POSITION = 2;
    private static final int LIVE_LIST_POSITION = 3;
    private static final int LIVE_DETAIL_POSITION = 4;
    private static final int NUMBER_OF_FRAGMENTS = 5;

    private static WeakReference<MessageFragment> MessageFragReference = new WeakReference<>(null);
    private static WeakReference<CameraFragment> CameraFragReference = new WeakReference<>(null);
    private static WeakReference<LiveFragment> LiveFragReference = new WeakReference<>(null);
    private static WeakReference<LocalFragment> LocalFragReference = new WeakReference<>(null);


    private static WeakReference<Bitmap> localCachedFirst = new WeakReference<>(null);
    private static WeakReference<Bitmap> localCachedSecond = new WeakReference<>(null);
    private static boolean currentBitmapToLoad = true;

    /** CAMERA MANAGEMENT
     */
    private boolean isCamera = false;
    Messenger cameraMessenger;


    private static final int CAMERA_POSITION_BACK = 0;
    private static final int CAMERA_POSITION_FRONT = 1;
    private static int currentCamera = CAMERA_POSITION_BACK;

<<<<<<< HEAD
=======
    private static boolean isTracking = false;
>>>>>>> a0109ac8d100d83e0d39841cc15523240ddbfb3f

    /** SERVICE MANAGEMENT
     */
    private boolean isBound = false;

    private Messenger mService = null;

    final Messenger messageHandler = new Messenger(new replyHandler().setParent(this));


    /**
     * ********************************************************************************************
     * <p>
     * LIFECYCLE MANAGEMENT
     * <p>
     * /**
     * Handles the initial loading of the app. Splash is defined in AndroidManifest
     *
     * @param savedInstanceState
     */
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        Log.d(TAG, "enter onCreate...");
        if (savedInstanceState != null) {
           //Restore the camerafragment's instance
            if (isCamera) {
                FragmentManager fm = getFragmentManager();
                try {
                    // camera = (CameraFragment) fm.getFragment(
                    //        savedInstanceState, "savedFragment");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }


        }
        super.onCreate(savedInstanceState);

        if (imageDir == null) {
            imageDir = getFilesDir() + "/";
        }


        //getActionBar().hide();


        //test for location settings enabled
        checkForLocationEnabled(this);

        //resolve DNS
        resolveDns("http://boomerang.ddns.net/");

        //loadGPS stuffs
        //ImageRequestService.startActionMonitorLocation(this, 0);
        //loads blank fragments
        createUI();

        //instantiate IPC with the service
        setUpServiceCommunication();

        //grabs stored images and loads
        findImages();

        //request images

        Log.d(TAG,"exit onCreate...");
    }


    @Override
    protected void onStart() {
        Log.d(TAG, "enter onStart...");
        super.onStart();


        Log.d(TAG, "binding the service to this class, creating if necessary");
        Intent intent = new Intent(this, ImageRequestService.class);
        bindService(intent, mConnection, Context.BIND_AUTO_CREATE);

        cameraMessenger = new Messenger(new CameraHandlerThread(this).cameraHandler);


        try {
            Message msg = Message.obtain(null, MSG_CONNECT_CAMERA, currentCamera, 0);
            cameraMessenger.send(msg);

        } catch (RemoteException e) {
            Log.e(TAG,"error sending message to connect camera");
        }


        if (isBound) {

            Log.d(TAG, "sending message to connect GoogleApiClient...");
            // Create and send a message to the service, using a supported 'what' value
            Message msg1 = Message.obtain(null, ImageRequestService.MSG_CONNECT_CLIENT, 0, 0);
              try {
                mService.send(msg1);
             } catch (RemoteException e) {
                e.printStackTrace();
            }
        }


        Log.d(TAG, "exit onStart...");
    }

    @Override
    protected void onResume() {
        super.onResume();
        Log.d(TAG, "enter onResume...");

        if (isCamera) {
            //loadCamera();
        }


        Log.d(TAG, "exit onResume...");
    }


    @Override
    protected void onPause() {
        super.onPause();
        Log.d(TAG, "enter onPause...");

        try {

            cameraMessenger.send(Message.obtain(null, MSG_DISCONNECT_CAMERA));

        } catch (RemoteException e) {
            Log.e(TAG,"error sending message to connect camera");
        }




        Log.d(TAG, "exit onPause...");
    }

    @Override
    protected void onStop() {
        super.onStop();

        Log.d(TAG, "enter onStop...");

        //connect the googleApiC

        //unbind the service now
        if (isBound) {
             Log.d(TAG, "sending message to disconnect GoogleApiClient...");
             Message msg1 = Message.obtain(null, ImageRequestService.MSG_DISCONNECT_CLIENT, 0, 0);
            try {
                mService.send(msg1);
            } catch (RemoteException e) {
                e.printStackTrace();
            }

            Log.d(TAG, "unbinding the service...");
            unbindService(mConnection);
            isBound = false;
        }

        Log.d(TAG, "exit onStop...");
    }


    protected void onDestroy() {
        super.onDestroy();
        Log.d(TAG, "enter onDestroy...");

        try {
            cameraMessenger.send(Message.obtain(null, MSG_ACTIVITY_DESTROYED));
        } catch (RemoteException e) {
            Log.e(TAG,"error notifying that fragment was destroyed",e);
        }

        Log.d(TAG, "exit onDestroy...");
    }


    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        Log.d(TAG, "enter onSavedInstanceState...");

        //saves the cameraFragment

        /*
        if (isCamera) {
            if (camera != null) {
                Log.d(TAG, "camera was not null");
                //getFragmentManager().putFragment(outState, "savedFragment", camera);
            } else {
                Log.e(TAG, "camera was null");
            }
        }*/


        Log.d(TAG, "exit onSavedInstanceState...");
    }

    @Override
    public void onTrimMemory(int level) {
        super.onTrimMemory(level);
        switch (level) {
            case TRIM_MEMORY_UI_HIDDEN:



        }




    }

    /***********************************************************************************************
     *
     * USER INTERACTION
     *
     */
    /**
     * class 'createUI'
     * <p>
     * instantiates the UI elements
     * its just a wrapper from the onCreate thread for niceness
     */
    private void createUI() {
        setContentView(R.layout.activity_main);

        mAdapter = new MainAdapter(getFragmentManager());
        mPager = (CustomViewPager) findViewById(R.id.pager);
        mPager.setAdapter(mAdapter);
        mPager.setCurrentItem(CAMERA_LIST_POSITION);
        //camera = CameraFragment.newInstance();
        //FragmentTransaction transaction = getFragmentManager().beginTransaction();
        //transaction.replace(R.id.rootlayout, camera);
        //transaction.hide(camera);
        //transaction.commit();

    }

    @Override
    public boolean onDoubleTap(MotionEvent e) {
        if (mPager.getCurrentItem() == CAMERA_LIST_POSITION) {
            sendMsgSwitchCamera();
        }
        return false;
    }

    @Override
    public boolean onDoubleTapEvent(MotionEvent e) {
        return false;
    }

    @Override
    public boolean onSingleTapConfirmed(MotionEvent e) {
        return false;
    }

    @Override
    public View onCreateView(String name, Context context, AttributeSet attrs) {


        return super.onCreateView(name, context, attrs);

    }



    /**
     * class 'MainAdapter'
     * <p>
     * handles the fragment instantiations, instantiating all of the fragments
     * permanently, and allows their navigation to be swipeable
     * <p>
     * makes use of the android support library
     */
    public static class MainAdapter extends FragmentStatePagerAdapter {


        public MainAdapter(FragmentManager fm) {
            super(fm);
        }

        @Override
        public int getCount() {
            return NUMBER_OF_FRAGMENTS;
        }

        /**
         * instantiates each fragment, and places at its individual placement
         *
         * uses weakreferences to each fragment to ensure calls are handled properly
         *
         * @param position current position the pager to place the fragment 0 through 2
         * @return the fragment to be instantiated
         */
        @Override
        public Fragment getItem(int position) {

            if (position == MESSAGE_LIST_POSITION) {
                if (MessageFragReference.get() == null){
                    MessageFragReference = new WeakReference<>(MessageFragment.newInstance("a","a"));
                }
                return MessageFragReference.get();
            } else if (position == LOCAL_LIST_POSITION) {
                if (LocalFragReference.get() == null) {
                    LocalFragReference = new WeakReference<>(LocalFragment.getInstance());
                }
                return LocalFragReference.get();
            } else if (position == LIVE_LIST_POSITION) {
                if (LiveFragReference.get() == null){
                    LiveFragReference = new WeakReference<>(LiveFragment.newInstance("a","a"));
                }
                return LiveFragReference.get();
            } else if (position == CAMERA_LIST_POSITION) {
                if (CameraFragReference.get() == null){
                    CameraFragReference = new WeakReference<>(CameraFragment.newInstance());
                }
                return CameraFragReference.get();
            } else if (position == LIVE_DETAIL_POSITION) {
                return LiveDetailFragment.newInstance(LiveFragment.getCurrentThread());
            } else {
                Log.e(TAG, "Invalid fragment position loaded");
                return null;
            }
        }
    }

    /**
     * methods "load Local, Live, and Message'
     * <p>
     * callback methods from the three fragment xml files ala android::onClick
     * merely sets the current fragment in the pager
     *
     * @param buttonView the view of the button being pressed
     */
    public void loadLocal(View buttonView) {
        mPager.setCurrentItem(LOCAL_LIST_POSITION);
    }

    public void loadLive(View buttonView) {
        mPager.setCurrentItem(LIVE_LIST_POSITION);
    }

    public void loadMessage(View buttonView) {
        mPager.setCurrentItem(MESSAGE_LIST_POSITION);
    }

    /**
     * method 'cancelCamera'
     * <p>
     * hides the camera fragment, does not remove it
     * <p>
     * called by various lifecycle methods, as well as by the camera Listener
     */
    /*public void cancelCamera() {
        FragmentTransaction transaction = getFragmentManager().beginTransaction();
        transaction.hide(camera);
        transaction.commit();
        isCamera = false;
    }*/
    public void loadCamera(View buttonView) {
        //loadCamera();
    }

    /**
     * method 'onBackPressed'
     * <p>
     * allows the back button to be used to close the camera fragment
     * overrides back button functionality application-wide
     */
    @Override
    public void onBackPressed() {
        super.onBackPressed();
    }

    /***********************************************************************************************
     * INITIALIZE
     *
     */
    /**
     * method checkForLocationEnabled
     * <p>
     * tests if the location services are enables
     *
     * @param context context of the location to be testing
     */
    public static void checkForLocationEnabled(final Context context) {

        LocationManager lm = null;
        boolean gps_enabled = false, network_enabled = false;
        if (lm == null)
            lm = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE);
        try {
            gps_enabled = lm.isProviderEnabled(LocationManager.GPS_PROVIDER);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        try {
            network_enabled = lm.isProviderEnabled(LocationManager.NETWORK_PROVIDER);
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        if (!gps_enabled && !network_enabled) {
            final AlertDialog.Builder dialog = new AlertDialog.Builder(context); //todo make this nicer
            dialog.setMessage(context.getResources().getString(R.string.gps_network_not_enabled));
            dialog.setPositiveButton(context.getResources().getString(R.string.open_location_settings), new DialogInterface.OnClickListener() {

                @Override
                public void onClick(DialogInterface paramDialogInterface, int paramInt) {
                    Intent myIntent = new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS);
                    context.startActivity(myIntent);
                    //get gps
                }
            });
            dialog.setNegativeButton(context.getString(R.string.Cancel), new DialogInterface.OnClickListener() {

                @Override
                public void onClick(DialogInterface paramDialogInterface, int paramInt) {
                    paramDialogInterface.dismiss();
                }
            });
            dialog.show();

        }
    }

    public boolean resolveDns(String address) {

        if (isBound) {

            Log.d(TAG, "sending message to resolve DNS...");
            Message msg = Message.obtain(null, ImageRequestService.MSG_RESOLVE_HOST, 0, 0);

            Bundle b = new Bundle(1);
            b.putString("hostname", address);
            msg.setData(b);


            try {
                mService.send(msg);
            } catch (RemoteException e) {
                e.printStackTrace();
            }
        }

        return true;
    }

    /**
     * method 'requestImages'
     *
     * requests images from the service
     * call back from {@link jokrapp.boomerang.LocalFragment.localFragmentListener}
     *
     * @param num of images to request from server
     */
    public void requestImages(int num) {

        if (isBound) {
            Log.d(TAG, "sending message to request " + num + " images");

            Message msg = Message.obtain(null, ImageRequestService.MSG_REQUEST_IMAGES,num,0);
            Bundle data = new Bundle();
            data.putInt(Constants.IMAGE_COUNT, num);
            msg.setData(data);

            try {
                msg.replyTo = messageHandler;
                mService.send(msg);
            } catch (RemoteException e) {
                Log.e(TAG, "error sending message to request images", e);
            }

        }
    }


    /**
     * method 'deleteImage'
     *
     * requests image to be deleted from database
     * call back from {@link jokrapp.boomerang.LocalFragment.localFragmentListener}
     *
     * @param filepath of image to delete from database
     */
    public void deleteImage(final String filepath) {

        new Thread(new Runnable() {
            @Override
            public void run() {
                if (isBound) {

                    Log.d(TAG, "sending message to delete " + filepath);
                    Message msg = Message.obtain(null, ImageRequestService.MSG_DELETE_IMAGE);

                    Bundle data = new Bundle();
                    data.putString(Constants.IMAGE_FILEPATH, filepath);
                    msg.setData(data);

                    try {
                        msg.replyTo = messageHandler;
                        mService.send(msg);
                    } catch (RemoteException e) {
                        Log.e(TAG,"error sending message to request images",e);
                    }
                }


            }

        }).start();
    }

    public void requestImages(View view) {
        LocalFragment.getInstance().resetDatabaseAndMap();
    }

    public void clearDatabase(View view) {
        Toast.makeText(this,"sending message to clear database",Toast.LENGTH_SHORT).show();
        if (isBound) {
            Log.d(TAG,"sending message to clear database");
            Message msg = Message.obtain(null, ImageRequestService.MSG_DELETE_IMAGE);

            Bundle data = new Bundle();
            data.putString(Constants.IMAGE_FILEPATH, null);
            msg.setData(data);

            try {
                msg.replyTo = messageHandler;
                mService.send(msg);
            } catch (RemoteException e) {
                Log.e(TAG,"error sending message to request images",e);
            }
        }
    }
    /***********************************************************************************************
     * CAMERA HANDLING
     *
     */
    /**
     * Create a file Uri for saving an image or video
     */

    /**
     * Create a File for saving an image or video
     */
    public File getInternalImageFile() {
        String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss",Locale.US).format(new Date());
<<<<<<< HEAD

        File file = new File(this.getFilesDir(), File.separator +
                "IMG_" + timeStamp + ".jpg");

        return file;
    }



    /** CAMERA HANDLER COMMUNICATION - HANDLER THREAD
     */
    public static final int MSG_CONNECT_CAMERA = 0;
    public static final int MSG_DISCONNECT_CAMERA = 1;
    public static final int MSG_START_PREVIEW = 2;
    public static final int MSG_STOP_PREVIEW = 3;
    public static final int MSG_ACTIVITY_DESTROYED = 4;
    public static final int MSG_TAKE_PICTURE = 5;
    public static final int MSG_SAVE_PICTURE = 6;
    public static final int MSG_SWITCH_CAMERA = 7;
    public static final int MSG_FLASH_ON = 8;
    public static final int MSG_FLASH_OFF = 9;


    /** CAMERA HANDLER COMMUNICATION - UI THREAD
     */
    public static final int MSG_PICTURE_TAKEN = -1;


    /**
     * class 'CameraHanderThread'
     *
     * this handler thread, an implementation of looper, serves as the background thread
     * to receive messages for the camera.
     *
     * the camera connection, image capturing, etc, is managed in this thread and this thread only
     */
    class CameraHandlerThread extends HandlerThread {
        private CameraHandler cameraHandler;

        CameraHandlerThread(MainActivity parent) {
            super("CameraHandlerThread");
            start();
            cameraHandler = new CameraHandler(parent);
        }



    }

    /**
     * Handles camera operation requests from other threads.  Necessary because the Camera
     * must only be accessed from one thread.
     */
    static class CameraHandler extends Handler {
        private static final String TAG = "MainCameraHandler";


        private static final int CAMERA_POSITION_BACK = 0;
        private static final int CAMERA_POSITION_FRONT = 1;

        /** SHARED PREFERENCES
         */
        private static final String FRONT_CAMERA_PARAMETERS = "fParams";
        private static final String BACK_CAMERA_PARAMETERS = "bParams";


        private Camera mCamera;

        private Messenger replyToMainThreadMessenger;

        private Camera.Parameters parameters;

        private byte[] theData;



        // Weak reference to the Activity; only access this from the UI thread.
        private WeakReference<MainActivity> mWeakActivity;

        public CameraHandler(MainActivity parent) {
            mWeakActivity = new WeakReference<>(parent);

            SharedPreferences p = PreferenceManager.getDefaultSharedPreferences(parent);

            /*
            if (currentCamera == CAMERA_POSITION_FRONT) {
                if (p.getString(FRONT_CAMERA_PARAMETERS,null)!=null){
                    parameters.unflatten(p.getString(FRONT_CAMERA_PARAMETERS,null));
                }
            } else {
                if (p.getString(BACK_CAMERA_PARAMETERS,null)!=null){
                    parameters.unflatten(p.getString(BACK_CAMERA_PARAMETERS,null));
                }
            }*/
        }

        /**
         * Drop the reference to the activity.  Useful as a paranoid measure to ensure that
         * attempts to access a stale Activity through a handler are caught.
         */
        public void invalidateHandler() {
            if (VERBOSE) {
                Log.v(TAG,"clearing weakreference to activity");
            }
            mWeakActivity.clear();
        }

        @Override  // runs on UI thread
        public void handleMessage(Message inputMessage) {
            int what = inputMessage.what;
            Log.d(TAG, "CameraHandler [" + this + "]: what=" + what);

            MainActivity activity = mWeakActivity.get();
            if (activity == null) {
                Log.w(TAG, "CameraHandler.handleMessage: activity is null");
                return;
            }

            switch (what) {
                case MSG_CONNECT_CAMERA: //0

                    Log.d(TAG,"connecting to camera, setting all attributes...");
                    mCamera = CameraFragment.getCameraInstance(inputMessage.arg1);
                    mCamera.setDisplayOrientation(90);
                    int width = activity.getResources().getDisplayMetrics().widthPixels;
                    int height = activity.getResources().getDisplayMetrics().heightPixels;

                    if (parameters == null) {
                        parameters = mCamera.getParameters();
                        Camera.Size mPreviewSize = calculateOptimalPreviewSize(
                                parameters.getSupportedPreviewSizes(),width,height);
                        Camera.Size mDisplaySize = calculateOptimalCameraResolution(
                                parameters.getSupportedPictureSizes());
                        parameters.setPictureSize(mDisplaySize.width,mDisplaySize.height);
                        parameters.setPreviewSize(mPreviewSize.width, mPreviewSize.height);
                        parameters.setRotation(90);
                        parameters.set("rotation", 90);
                        SharedPreferences.Editor editor = PreferenceManager.
                                getDefaultSharedPreferences(mWeakActivity.get()).edit();
                        if (currentCamera == CAMERA_POSITION_FRONT) {
                            editor.putString(FRONT_CAMERA_PARAMETERS,parameters.flatten());
                        } else {
                            editor.putString(BACK_CAMERA_PARAMETERS,parameters.flatten());
                        }
                        Log.i(TAG,"storing calculated camera parameters to SharedPreferences");
                        editor.commit();
                    }

                    mCamera.setParameters(parameters);
                    Log.d(TAG,"camera connected, all attributes set.");
                    break;
                case MSG_DISCONNECT_CAMERA: //1
                    mCamera.release();
                    mCamera = null;
                    break;

                case MSG_START_PREVIEW: //2
                    try {
                        Log.d(TAG,"setting and starting preview...");

                        mCamera.setPreviewDisplay(CameraFragReference.get().getPreviewHolder());
                        mCamera.startPreview();

                    } catch (IOException e) {
                        Log.e(TAG,"error setting preview holder",e);
                    } catch (Exception e) {
                        Log.e(TAG,"generic error setting and starting preview",e);
                    }
                    break;
                case MSG_STOP_PREVIEW: //3
                    if (mCamera != null) {
                        mCamera.stopPreview();
                    }
                    break;
                case MSG_TAKE_PICTURE: //5
                    mCamera.takePicture(null,null,mPicture);
                    replyToMainThreadMessenger = inputMessage.replyTo;

                    break;
                case MSG_SAVE_PICTURE: //6
                    saveImage(theData);
                    theData = null;
                    break;
                case MSG_SWITCH_CAMERA: //7

                    Log.d(TAG,"switching to camera: " + inputMessage.arg1);
                    mCamera.stopPreview();
                    mCamera.release();
                    mCamera = CameraFragment.getCameraInstance(inputMessage.arg1);

                    try {
                        mCamera.setPreviewDisplay(CameraFragReference.get().getPreviewHolder());
                    } catch (IOException e) {
                        Log.e(TAG,"error setting preview display",e);
                    }
                    mCamera.setDisplayOrientation(90);

                    int sWidth = activity.getResources().getDisplayMetrics().widthPixels;
                    int sHeight = activity.getResources().getDisplayMetrics().heightPixels;

                        parameters = mCamera.getParameters();
                        Camera.Size mFpreviewSize = calculateOptimalPreviewSize(
                                parameters.getSupportedPreviewSizes(),sWidth,sHeight);
                        Camera.Size mFdisplaySize = calculateOptimalCameraResolution(
                                parameters.getSupportedPictureSizes());
                        parameters.setPictureSize(mFdisplaySize.width,mFdisplaySize.height);
                        parameters.setPreviewSize(mFpreviewSize.width, mFpreviewSize.height);
                        parameters.setRotation(90);
                        parameters.set("rotation", 90);


                        mCamera.setParameters(parameters);

                    mCamera.startPreview();

                    break;
                case MSG_FLASH_ON: //8

                        if (parameters.getSupportedFlashModes().
                                contains(Camera.Parameters.FLASH_MODE_ON)) {
                            parameters.setFlashMode(Camera.Parameters.FLASH_MODE_ON);
                            mCamera.setParameters(parameters);
                        }

                    break;

                case MSG_FLASH_OFF: //9

                        if (parameters.getSupportedFlashModes().
                                contains(Camera.Parameters.FLASH_MODE_OFF)) {
                           parameters.setFlashMode(Camera.Parameters.FLASH_MODE_OFF);
                           mCamera.setParameters(parameters);
                      }

                    break;

                case MSG_PICTURE_TAKEN: //-1 reply in main UI
                    CameraFragReference.get().onPictureTaken(1);
                    break;
                case MSG_ACTIVITY_DESTROYED: //4
                    invalidateHandler();
                    break;


                default:
                    throw new RuntimeException("unknown msg " + what);
            }
        }


        /**
         * Interface to receive picture callback from the capturebutton
         *
         * sets a new click listener for the confirm button, which saves the file
         */
        private final android.hardware.Camera.PictureCallback mPicture =
                new android.hardware.Camera.PictureCallback() {

                    /**
                     * method 'onPictureTaken'
                     *
                     * the method that is called when a picture is taken
                     *
                     * @param data the byte array data of the image that was taken
                     * @param camera the camera from which the picture was taken
                     */
                    @Override
                    public void onPictureTaken(final byte[] data, android.hardware.Camera camera) {
                        if (VERBOSE) {
                            Log.v(TAG, "enter onPictureTaken... ");
                        }
                        theData = data;
                        Log.d(TAG,"taking picture...");

                        try {
                            replyToMainThreadMessenger.send(Message.obtain(null, MSG_PICTURE_TAKEN));
                        } catch (RemoteException e) {
                            Log.e(TAG,"error notifying that picture was taken...",e);
                        }
                        if (VERBOSE) {
                            Log.v(TAG, "exit onPictureTaken... ");
                        }

                        replyToMainThreadMessenger = null;
                    }


                };

        public void saveImage(byte[] data) {
            Log.d(TAG,"saving image...");

            String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());

            File pictureFile = new File(mWeakActivity.get().getFilesDir(),
                    "IMG_" + timeStamp + ".jpg");

            String filePath = pictureFile.getAbsolutePath();

            if (pictureFile == null) {
                Log.e(TAG,"no file was able to be opened");
                return;
            }

            try {
                Log.d(TAG, "Saving file to... " + filePath);

                Log.d(TAG,"The size of the image before compression: " + data.length);
                Bitmap image = BitmapFactory.decodeByteArray(data,0,data.length);
                FileOutputStream fos = new FileOutputStream(filePath);
                image.compress(Bitmap.CompressFormat.JPEG,100,fos);
                Log.d(TAG,"The size of the image after: " + data.length);
                fos.write(data);
                fos.close();

                Log.d(TAG, "notifying MainActivity to send image to server...");
                mWeakActivity.get().onImageSaved(filePath);

            } catch (FileNotFoundException e) {
                Log.d(TAG, "File not found: " + e.getMessage());
            } catch (IOException e) {
                Log.d(TAG, "Error accessing file: " + e.getMessage());
            } catch (Exception e) {
                Log.e(TAG,"error saving image to internal storage", e);
            }
            if (VERBOSE) {
                Log.v(TAG,"exit savePicture...");
            }
        }



        /**
         * method 'getOptionalPreviewSize'
         *
         * finds the best preview size to aspect ratio and returns the size
         *
         * @param sizes camera sizes available
         * @param w width to aim for
         * @param h height to aim for
         * @return the optinal Camera.size for the preview
         */
        private Camera.Size calculateOptimalPreviewSize(List<Camera.Size> sizes, int w, int h) {
            if (VERBOSE) {
                Log.v(TAG, "enter calculateOptimalPreviewSize...");
            }

            final double ASPECT_TOLERANCE = 0.1;
            double targetRatio = (double) h / w;

            if (sizes == null) return null;

            Camera.Size optimalSize = null;
            double minDiff = Double.MAX_VALUE;

            int targetHeight = h;

            for (Camera.Size size : sizes) {
                double ratio = (double) size.width / size.height;
                if (Math.abs(ratio - targetRatio) > ASPECT_TOLERANCE) continue;
                if (Math.abs(size.height - targetHeight) < minDiff) {
                    optimalSize = size;
                    minDiff = Math.abs(size.height - targetHeight);
                }
            }

            if (optimalSize == null) {
                minDiff = Double.MAX_VALUE;
                for (Camera.Size size : sizes) {
                    if (Math.abs(size.height - targetHeight) < minDiff) {
                        optimalSize = size;
                        minDiff = Math.abs(size.height - targetHeight);
                    }
                }
            }
            if (VERBOSE) {
                Log.d(TAG,"optimal" +
                        "preview size found is " + optimalSize.height + ", " + optimalSize.width);
                Log.v(TAG,"exit calculateOptimalPreviewSize...");
            }
            return optimalSize;
        }


        /**
         * method 'getOptionalPreviewSize'
         *
         * grabs the best preview size from shared preferences, or calculates it through
         * calculateOptimalPreviewSize
         *
         * @param camera the camera with which to measure
         * @param w width to aim for
         * @param h height to aim for
         * @return the optinal Camera.size for the preview
         *//*
        private Camera.Size getOptimalPreviewSize(Camera camera, int w, int h) {
            if (VERBOSE) {
                Log.v(TAG,"enter getOptimalPreviewSize...");
            }
            SharedPreferences p = PreferenceManager.getDefaultSharedPreferences(mWeakActivity.get().getApplicationContext());


            Camera.Size optimalSize;

            int width;
            int height;

            if (currentCamera  == CAMERA_POSITION_FRONT) {
                width = p.getInt(PREVIEW_WIDTH_FRONT, -1);
                height = p.getInt(PREVIEW_HEIGHT_FRONT, -1);


                if (width == -1) {//preview size has yet to be measured
                    Log.d(TAG,"Measuring front camera preview dimensions");

                    optimalSize = calculateOptimalPreviewSize(camera.getParameters().getSupportedPreviewSizes(),w,h);

                    p.edit().putInt(PREVIEW_WIDTH_FRONT, optimalSize.width).apply();
                    p.edit().putInt(PREVIEW_HEIGHT_FRONT, optimalSize.height).apply();
                } else {
                    optimalSize = camera.new Size(width,height);
                }

            } else {

                width = p.getInt(PREVIEW_WIDTH_BACK, -1);
                height = p.getInt(PREVIEW_HEIGHT_BACK, -1);

                if (width == -1) {//preview size has yet to be measured
                    Log.d(TAG,"Measuring back camera preview dimensions");

                    optimalSize = calculateOptimalPreviewSize(camera.getParameters().getSupportedPreviewSizes(),w,h);

                    p.edit().putInt(PREVIEW_WIDTH_BACK, optimalSize.width).apply();
                    p.edit().putInt(PREVIEW_HEIGHT_BACK, optimalSize.height).apply();

                } else {
                    optimalSize = camera.new Size(width,height);
                }
            }

            if (VERBOSE) {
                Log.v(TAG,"exit getOptimalPreviewSize...");
            }

            return optimalSize;
        }

        private Camera.Size getOptimalCameraResolution(Camera camera) {
            SharedPreferences p = PreferenceManager.getDefaultSharedPreferences(mWeakActivity.get().getApplicationContext());
            int optimalWidth= p.getInt(RESOLUTION_WIDTH, -1);
            int optimalHeight= p.getInt(RESOLUTION_HEIGHT, -1);
            if (optimalWidth != -1 || optimalHeight != -1) {
                return camera.new Size(optimalWidth, optimalHeight);
            } else {
                Camera.Size size =calculateOptimalCameraResolution(camera);
                p.edit().putInt(RESOLUTION_WIDTH,size.width).apply();
                p.edit().putInt(RESOLUTION_HEIGHT,size.height).apply();
                return size;
            }
        }*/


        /**
         * static method 'calculateOptimalResolution'
         *
         * tests available resolutions of the provided camera, first checks if it supports
         * the optimal resolution. Should that resolution not be available, it then attempts to
         * calculate the resolution which is closest to the optimal.
         *
         * Uses the distance formula in {@link SQLiteDbHelper}
         *
         * @param sizes avaiable camera resolution sizes
         * @return best resolution available
         */
        private Camera.Size calculateOptimalCameraResolution(List<Camera.Size> sizes) {
            if (VERBOSE) {
                Log.v(TAG,"enter calculateOptimalResolution...");
            }

            if (VERBOSE) {
                Log.v(TAG, "viable image sizes: ");
                for(int i = 0; i < sizes.size(); i++) {
                    Log.v(" ", " " + sizes.get(i).width + sizes.get(i).height);
                }
            }


            //for each size, first, do they have it? - try each size
            for (Camera.Size s : sizes) {
                if (s.width == Constants.IDEAL_WIDTH) {
                    if (s.height == Constants.IDEAL_HEIGHT) {
                        //found it
                        Log.d(TAG,"perfect resolution found! " + s.width + ", " + s.height);
                        return s;
                    }
                }
            }

            //guess it failed, calculation time
            Log.d(TAG,"perfect resolution not found.");

            int closestDistance = 9000;
            Camera.Size closestSize = sizes.get(sizes.size()-1);

            for (Camera.Size s : sizes) {
                Double currentDistance = SQLiteDbHelper.distanceFormula(s.width,s.height,
                        Constants.IDEAL_WIDTH,Constants.IDEAL_HEIGHT);

                if (currentDistance < closestDistance) {
                    closestDistance = currentDistance.intValue();
                    closestSize = s;

                }
            }
            Log.d(TAG,"closestSize found is: " + closestSize.width + ", " + closestSize.height);

            if (VERBOSE) {
                Log.v(TAG, "exit calculateOptimalResolution...");
            }
            return closestSize;
        }



    }

    public void sendMsgStartPreview() {
        if (VERBOSE) {
            Log.v(TAG,"received callback from CameraFragment");
            Log.v(TAG,"entering sendMsgStartPreview");
        }
        try {
            cameraMessenger.send(Message.obtain(null, MSG_START_PREVIEW));
        } catch (RemoteException e) {
            Log.e(TAG,"error sending message to start Preview");
        }

=======
>>>>>>> a0109ac8d100d83e0d39841cc15523240ddbfb3f

        if (VERBOSE)
            Log.v(TAG,"exiting sendMsgStartPreview()");
    }

    public void sendMsgStopPreview() {
        if (VERBOSE) {
            Log.v(TAG, "entering sendMsgStopPreview...");
        }
        try {
            cameraMessenger.send(Message.obtain(null, MSG_STOP_PREVIEW));
        } catch (RemoteException e) {
            Log.e(TAG,"error sending message to stop Preview");
        }

        if (VERBOSE) {
            Log.v(TAG, "exiting sendMsgStopPreview...");
        }
    }

    public void sendMsgTakePicture() {
        if (VERBOSE) {
            Log.v(TAG,"entering sendMsgTakePicture...");
        }

        try {
            Message msg = Message.obtain(null,MSG_TAKE_PICTURE);
            msg.replyTo = new Messenger(new CameraHandler(this));
            cameraMessenger.send(msg);
        } catch (RemoteException e) {
            Log.e(TAG,"error sending message to take picture");
        }

        if (VERBOSE) {
            Log.v(TAG,"exiting sendMsgTakePicture...");
        }

    }

    public void sendMsgSaveImage() {
        if (VERBOSE) {
            Log.v(TAG, "entering sendMsgSaveImage...");
        }
        try {
            cameraMessenger.send(Message.obtain(null, MSG_SAVE_PICTURE));
        } catch (RemoteException e) {
            Log.e(TAG,"error sending message to save image");
        }

        if (VERBOSE) {
            Log.v(TAG, "exiting sendMsgSaveImage...");
        }
    }

    public void sendMsgSwitchCamera() {
        if (VERBOSE) {
            Log.v(TAG, "entering sendMsgSaveImage...");
        }
        if (currentCamera == CAMERA_POSITION_FRONT) {
            currentCamera = CAMERA_POSITION_BACK;
        } else {
            currentCamera = CAMERA_POSITION_FRONT;
        }

        try {
            cameraMessenger.send(Message.obtain(null, MSG_SWITCH_CAMERA, currentCamera, 0));
        } catch (RemoteException e) {
            Log.e(TAG,"error sending message to save image");
        }

        if (VERBOSE) {
            Log.v(TAG, "exiting sendMsgSaveImage...");
        }
    }

<<<<<<< HEAD
    public void setFlash(View view) {
        if (VERBOSE) {
            Log.v(TAG, "entering setFlash...");
        }

        CheckBox flashBox = (CheckBox)view;

        if (flashBox.isChecked()) {
            try {
                cameraMessenger.send(Message.obtain(null, MSG_FLASH_ON));
            } catch (RemoteException e) {
                Log.e(TAG,"error sending message to save image");
            }
        } else {
            try {
                cameraMessenger.send(Message.obtain(null, MSG_FLASH_OFF));
            } catch (RemoteException e) {
                Log.e(TAG,"error sending message to save image");
            }
        }

        if (VERBOSE) {
            Log.v(TAG, "exiting setFlash...");
=======
    /** CAMERA HANDLER COMMUNICATION - HANDLER THREAD
     */
    public static final int MSG_CONNECT_CAMERA = 0;
    public static final int MSG_DISCONNECT_CAMERA = 1;
    public static final int MSG_START_PREVIEW = 2;
    public static final int MSG_STOP_PREVIEW = 3;
    public static final int MSG_ACTIVITY_DESTROYED = 4;
    public static final int MSG_TAKE_PICTURE = 5;
    public static final int MSG_SAVE_PICTURE = 6;
    public static final int MSG_SWITCH_CAMERA = 7;


    /** CAMERA HANDLER COMMUNICATION - UI THREAD
     */
    public static final int MSG_PICTURE_TAKEN = -1;


    /**
     * class 'CameraHanderThread'
     *
     * this handler thread, an implementation of looper, serves as the background thread
     * to receive messages for the camera.
     *
     * the camera connection, image capturing, etc, is managed in this thread and this thread only
     */
    class CameraHandlerThread extends HandlerThread {
        private CameraHandler cameraHandler;

        CameraHandlerThread(MainActivity parent) {
            super("CameraHandlerThread");
            start();
            cameraHandler = new CameraHandler(parent);
        }



    }

    /**
     * Handles camera operation requests from other threads.  Necessary because the Camera
     * must only be accessed from one thread.
     */
    static class CameraHandler extends Handler {
        private static final String TAG = "MainCameraHandler";


        private static final int CAMERA_POSITION_BACK = 0;
        private static final int CAMERA_POSITION_FRONT = 1;

        /** SHARED PREFERENCES
         */
        private static final String FRONT_CAMERA_PARAMETERS = "fParams";
        private static final String BACK_CAMERA_PARAMETERS = "bParams";


        private Camera mCamera;

        private Messenger replyToMainThreadMessenger;

        private Camera.Parameters parameters;

        private byte[] theData;



        // Weak reference to the Activity; only access this from the UI thread.
        private WeakReference<MainActivity> mWeakActivity;

        public CameraHandler(MainActivity parent) {
            mWeakActivity = new WeakReference<>(parent);

            SharedPreferences p = PreferenceManager.getDefaultSharedPreferences(parent);

            if (currentCamera == CAMERA_POSITION_FRONT) {
                if (p.getString(FRONT_CAMERA_PARAMETERS,null)!=null){
                    parameters.unflatten(p.getString(FRONT_CAMERA_PARAMETERS,null));
                }
            } else {
                if (p.getString(FRONT_CAMERA_PARAMETERS,null)!=null){
                    parameters.unflatten(p.getString(BACK_CAMERA_PARAMETERS,null));
                }
            }
        }

        /**
         * Drop the reference to the activity.  Useful as a paranoid measure to ensure that
         * attempts to access a stale Activity through a handler are caught.
         */
        public void invalidateHandler() {
            if (VERBOSE) {
                Log.v(TAG,"clearing weakreference to activity");
            }
            mWeakActivity.clear();
        }

        @Override  // runs on UI thread
        public void handleMessage(Message inputMessage) {
            int what = inputMessage.what;
            Log.d(TAG, "CameraHandler [" + this + "]: what=" + what);

            MainActivity activity = mWeakActivity.get();
            if (activity == null) {
                Log.w(TAG, "CameraHandler.handleMessage: activity is null");
                return;
            }

            switch (what) {
                case MSG_CONNECT_CAMERA: //0

                    Log.d(TAG,"connecting to camera, setting all attributes...");
                    mCamera = CameraFragment.getCameraInstance(inputMessage.arg1);
                    mCamera.setDisplayOrientation(90);
                    int width = activity.getResources().getDisplayMetrics().widthPixels;
                    int height = activity.getResources().getDisplayMetrics().heightPixels;

                    if (parameters == null) {
                        parameters = mCamera.getParameters();
                        Camera.Size mPreviewSize = calculateOptimalPreviewSize(
                                parameters.getSupportedPreviewSizes(),width,height);
                        Camera.Size mDisplaySize = calculateOptimalCameraResolution(
                                parameters.getSupportedPictureSizes());
                        parameters.setPictureSize(mDisplaySize.width,mDisplaySize.height);
                        parameters.setPreviewSize(mPreviewSize.width, mPreviewSize.height);
                        parameters.setRotation(90);
                        parameters.set("rotation", 90);
                        SharedPreferences.Editor editor = PreferenceManager.
                                getDefaultSharedPreferences(mWeakActivity.get()).edit();
                        if (currentCamera == CAMERA_POSITION_FRONT) {
                            editor.putString(FRONT_CAMERA_PARAMETERS,parameters.flatten());
                        } else {
                            editor.putString(BACK_CAMERA_PARAMETERS,parameters.flatten());
                        }
                        Log.i(TAG,"storing calculated camera parameters to SharedPreferences");
                        editor.apply();
                    }

                    mCamera.setParameters(parameters);
                    Log.d(TAG,"camera connected, all attributes set.");
                    break;
                case MSG_DISCONNECT_CAMERA: //1
                    mCamera.release();
                    mCamera = null;
                    break;

                case MSG_START_PREVIEW: //2
                    try {
                        Log.d(TAG,"setting and starting preview...");

                        mCamera.setPreviewDisplay(CameraFragReference.get().getPreviewHolder());
                        mCamera.startPreview();

                    } catch (IOException e) {
                        Log.e(TAG,"error setting preview holder",e);
                    } catch (Exception e) {
                        Log.e(TAG,"generic error setting and starting preview",e);
                    }
                    break;
                case MSG_STOP_PREVIEW: //3
                    if (mCamera != null) {
                        mCamera.stopPreview();
                    }
                    break;
                case MSG_TAKE_PICTURE: //5
                    mCamera.takePicture(null,null,mPicture);
                    replyToMainThreadMessenger = inputMessage.replyTo;

                    break;
                case MSG_SAVE_PICTURE: //6
                    saveImage(theData);
                    theData = null;
                    break;
                case MSG_SWITCH_CAMERA: //7

                    Log.d(TAG,"switching to camera: " + inputMessage.arg1);
                    mCamera.stopPreview();
                    mCamera.release();
                    mCamera = CameraFragment.getCameraInstance(inputMessage.arg1);

                    try {
                        mCamera.setPreviewDisplay(CameraFragReference.get().getPreviewHolder());
                    } catch (IOException e) {
                        Log.e(TAG,"error setting preview display",e);
                    }
                    mCamera.setDisplayOrientation(90);

                    int sWidth = activity.getResources().getDisplayMetrics().widthPixels;
                    int sHeight = activity.getResources().getDisplayMetrics().heightPixels;

                        parameters = mCamera.getParameters();
                        Camera.Size mFpreviewSize = calculateOptimalPreviewSize(
                                parameters.getSupportedPreviewSizes(),sWidth,sHeight);
                        Camera.Size mFdisplaySize = calculateOptimalCameraResolution(
                                parameters.getSupportedPictureSizes());
                        parameters.setPictureSize(mFdisplaySize.width,mFdisplaySize.height);
                        parameters.setPreviewSize(mFpreviewSize.width, mFpreviewSize.height);
                        parameters.setRotation(90);
                        parameters.set("rotation", 90);
                        mCamera.setParameters(parameters);

                    mCamera.startPreview();

                    break;
                case MSG_PICTURE_TAKEN: //-1 reply in main UI
                    CameraFragReference.get().onPictureTaken(1);
                    break;
                case MSG_ACTIVITY_DESTROYED: //4
                    invalidateHandler();
                    break;


                default:
                    throw new RuntimeException("unknown msg " + what);
            }
        }


        /**
         * Interface to receive picture callback from the capturebutton
         *
         * sets a new click listener for the confirm button, which saves the file
         */
        private final android.hardware.Camera.PictureCallback mPicture =
                new android.hardware.Camera.PictureCallback() {

                    /**
                     * method 'onPictureTaken'
                     *
                     * the method that is called when a picture is taken
                     *
                     * @param data the byte array data of the image that was taken
                     * @param camera the camera from which the picture was taken
                     */
                    @Override
                    public void onPictureTaken(final byte[] data, android.hardware.Camera camera) {
                        if (VERBOSE) {
                            Log.v(TAG, "enter onPictureTaken... ");
                        }
                        theData = data;
                        Log.d(TAG,"taking picture...");

                        try {
                            replyToMainThreadMessenger.send(Message.obtain(null, MSG_PICTURE_TAKEN));
                        } catch (RemoteException e) {
                            Log.e(TAG,"error notifying that picture was taken...",e);
                        }
                        if (VERBOSE) {
                            Log.v(TAG, "exit onPictureTaken... ");
                        }

                        replyToMainThreadMessenger = null;
                    }


                };

        public void saveImage(byte[] data) {
            Log.d(TAG,"saving image...");

            String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());

            File pictureFile = new File(mWeakActivity.get().getFilesDir(),
                    "IMG_" + timeStamp + ".jpg");

            String filePath = pictureFile.getAbsolutePath();

            if (pictureFile == null) {
                Log.e(TAG,"no file was able to be opened");
                return;
            }

            try {
                Log.d(TAG, "Saving file to... " + filePath);

                Log.d(TAG,"The size of the image before compression: " + data.length);
                Bitmap image = BitmapFactory.decodeByteArray(data,0,data.length);
                FileOutputStream fos = new FileOutputStream(filePath);
                image.compress(Bitmap.CompressFormat.JPEG,100,fos);
                Log.d(TAG,"The size of the image after: " + data.length);
                fos.write(data);
                fos.close();

                Log.d(TAG, "notifying MainActivity to send image to server...");
                mWeakActivity.get().onImageSaved(filePath);

            } catch (FileNotFoundException e) {
                Log.d(TAG, "File not found: " + e.getMessage());
            } catch (IOException e) {
                Log.d(TAG, "Error accessing file: " + e.getMessage());
            } catch (Exception e) {
                Log.e(TAG,"error saving image to internal storage", e);
            }
            if (VERBOSE) {
                Log.v(TAG,"exit savePicture...");
            }
        }



        /**
         * method 'getOptionalPreviewSize'
         *
         * finds the best preview size to aspect ratio and returns the size
         *
         * @param sizes camera sizes available
         * @param w width to aim for
         * @param h height to aim for
         * @return the optinal Camera.size for the preview
         */
        private Camera.Size calculateOptimalPreviewSize(List<Camera.Size> sizes, int w, int h) {
            if (VERBOSE) {
                Log.v(TAG, "enter calculateOptimalPreviewSize...");
            }

            final double ASPECT_TOLERANCE = 0.1;
            double targetRatio = (double) h / w;

            if (sizes == null) return null;

            Camera.Size optimalSize = null;
            double minDiff = Double.MAX_VALUE;

            int targetHeight = h;

            for (Camera.Size size : sizes) {
                double ratio = (double) size.width / size.height;
                if (Math.abs(ratio - targetRatio) > ASPECT_TOLERANCE) continue;
                if (Math.abs(size.height - targetHeight) < minDiff) {
                    optimalSize = size;
                    minDiff = Math.abs(size.height - targetHeight);
                }
            }

            if (optimalSize == null) {
                minDiff = Double.MAX_VALUE;
                for (Camera.Size size : sizes) {
                    if (Math.abs(size.height - targetHeight) < minDiff) {
                        optimalSize = size;
                        minDiff = Math.abs(size.height - targetHeight);
                    }
                }
            }
            if (VERBOSE) {
                Log.d(TAG,"optimal" +
                        "preview size found is " + optimalSize.height + ", " + optimalSize.width);
                Log.v(TAG,"exit calculateOptimalPreviewSize...");
            }
            return optimalSize;
        }


        /**
         * method 'getOptionalPreviewSize'
         *
         * grabs the best preview size from shared preferences, or calculates it through
         * calculateOptimalPreviewSize
         *
         * @param camera the camera with which to measure
         * @param w width to aim for
         * @param h height to aim for
         * @return the optinal Camera.size for the preview
         *//*
        private Camera.Size getOptimalPreviewSize(Camera camera, int w, int h) {
            if (VERBOSE) {
                Log.v(TAG,"enter getOptimalPreviewSize...");
            }
            SharedPreferences p = PreferenceManager.getDefaultSharedPreferences(mWeakActivity.get().getApplicationContext());


            Camera.Size optimalSize;

            int width;
            int height;

            if (currentCamera  == CAMERA_POSITION_FRONT) {
                width = p.getInt(PREVIEW_WIDTH_FRONT, -1);
                height = p.getInt(PREVIEW_HEIGHT_FRONT, -1);


                if (width == -1) {//preview size has yet to be measured
                    Log.d(TAG,"Measuring front camera preview dimensions");

                    optimalSize = calculateOptimalPreviewSize(camera.getParameters().getSupportedPreviewSizes(),w,h);

                    p.edit().putInt(PREVIEW_WIDTH_FRONT, optimalSize.width).apply();
                    p.edit().putInt(PREVIEW_HEIGHT_FRONT, optimalSize.height).apply();
                } else {
                    optimalSize = camera.new Size(width,height);
                }

            } else {

                width = p.getInt(PREVIEW_WIDTH_BACK, -1);
                height = p.getInt(PREVIEW_HEIGHT_BACK, -1);

                if (width == -1) {//preview size has yet to be measured
                    Log.d(TAG,"Measuring back camera preview dimensions");

                    optimalSize = calculateOptimalPreviewSize(camera.getParameters().getSupportedPreviewSizes(),w,h);

                    p.edit().putInt(PREVIEW_WIDTH_BACK, optimalSize.width).apply();
                    p.edit().putInt(PREVIEW_HEIGHT_BACK, optimalSize.height).apply();

                } else {
                    optimalSize = camera.new Size(width,height);
                }
            }

            if (VERBOSE) {
                Log.v(TAG,"exit getOptimalPreviewSize...");
            }

            return optimalSize;
        }

        private Camera.Size getOptimalCameraResolution(Camera camera) {
            SharedPreferences p = PreferenceManager.getDefaultSharedPreferences(mWeakActivity.get().getApplicationContext());
            int optimalWidth= p.getInt(RESOLUTION_WIDTH, -1);
            int optimalHeight= p.getInt(RESOLUTION_HEIGHT, -1);
            if (optimalWidth != -1 || optimalHeight != -1) {
                return camera.new Size(optimalWidth, optimalHeight);
            } else {
                Camera.Size size =calculateOptimalCameraResolution(camera);
                p.edit().putInt(RESOLUTION_WIDTH,size.width).apply();
                p.edit().putInt(RESOLUTION_HEIGHT,size.height).apply();
                return size;
            }
        }*/


        /**
         * static method 'calculateOptimalResolution'
         *
         * tests available resolutions of the provided camera, first checks if it supports
         * the optimal resolution. Should that resolution not be available, it then attempts to
         * calculate the resolution which is closest to the optimal.
         *
         * Uses the distance formula in {@link SQLiteDbHelper}
         *
         * @param sizes avaiable camera resolution sizes
         * @return best resolution available
         */
        private Camera.Size calculateOptimalCameraResolution(List<Camera.Size> sizes) {
            if (VERBOSE) {
                Log.v(TAG,"enter calculateOptimalResolution...");
            }

            if (VERBOSE) {
                Log.v(TAG, "viable image sizes: ");
                for(int i = 0; i < sizes.size(); i++) {
                    Log.v(" ", " " + sizes.get(i).width + sizes.get(i).height);
                }
            }


            //for each size, first, do they have it? - try each size
            for (Camera.Size s : sizes) {
                if (s.width == Constants.IDEAL_WIDTH) {
                    if (s.height == Constants.IDEAL_HEIGHT) {
                        //found it
                        Log.d(TAG,"perfect resolution found! " + s.width + ", " + s.height);
                        return s;
                    }
                }
            }

            //guess it failed, calculation time
            Log.d(TAG,"perfect resolution not found.");

            int closestDistance = 9000;
            Camera.Size closestSize = sizes.get(sizes.size()-1);

            for (Camera.Size s : sizes) {
                Double currentDistance = SQLiteDbHelper.distanceFormula(s.width,s.height,
                        Constants.IDEAL_WIDTH,Constants.IDEAL_HEIGHT);

                if (currentDistance < closestDistance) {
                    closestDistance = currentDistance.intValue();
                    closestSize = s;

                }
            }
            Log.d(TAG,"closestSize found is: " + closestSize.width + ", " + closestSize.height);

            if (VERBOSE) {
                Log.v(TAG, "exit calculateOptimalResolution...");
            }
            return closestSize;
        }



    }

    public void sendMsgStartPreview() {
        if (VERBOSE) {
            Log.v(TAG,"received callback from CameraFragment");
            Log.v(TAG,"entering sendMsgStartPreview");
        }
        try {
            cameraMessenger.send(Message.obtain(null, MSG_START_PREVIEW));
        } catch (RemoteException e) {
            Log.e(TAG,"error sending message to start Preview");
        }


        if (VERBOSE)
            Log.v(TAG,"exiting sendMsgStartPreview()");
    }

    public void sendMsgStopPreview() {
        if (VERBOSE) {
            Log.v(TAG, "entering sendMsgStopPreview...");
        }
        try {
            cameraMessenger.send(Message.obtain(null, MSG_STOP_PREVIEW));
        } catch (RemoteException e) {
            Log.e(TAG,"error sending message to stop Preview");
        }

        if (VERBOSE) {
            Log.v(TAG, "exiting sendMsgStopPreview...");
        }
    }

    public void sendMsgTakePicture() {
        if (VERBOSE) {
            Log.v(TAG,"entering sendMsgTakePicture...");
        }

        try {
            Message msg = Message.obtain(null,MSG_TAKE_PICTURE);
            msg.replyTo = new Messenger(new CameraHandler(this));
            cameraMessenger.send(msg);
        } catch (RemoteException e) {
            Log.e(TAG,"error sending message to take picture");
        }

        if (VERBOSE) {
            Log.v(TAG,"exiting sendMsgTakePicture...");
        }

    }

    public void sendMsgSaveImage() {
        if (VERBOSE) {
            Log.v(TAG, "entering sendMsgSaveImage...");
        }
        try {
            cameraMessenger.send(Message.obtain(null, MSG_SAVE_PICTURE));
        } catch (RemoteException e) {
            Log.e(TAG,"error sending message to save image");
        }

        if (VERBOSE) {
            Log.v(TAG, "exiting sendMsgSaveImage...");
        }
    }

    public void sendMsgSwitchCamera() {
        if (VERBOSE) {
            Log.v(TAG, "entering sendMsgSaveImage...");
        }
        if (currentCamera == CAMERA_POSITION_FRONT) {
            currentCamera = CAMERA_POSITION_BACK;
        } else {
            currentCamera = CAMERA_POSITION_FRONT;
        }

        try {
            cameraMessenger.send(Message.obtain(null, MSG_SWITCH_CAMERA, currentCamera, 0));
        } catch (RemoteException e) {
            Log.e(TAG,"error sending message to save image");
        }

        if (VERBOSE) {
            Log.v(TAG, "exiting sendMsgSaveImage...");
>>>>>>> a0109ac8d100d83e0d39841cc15523240ddbfb3f
        }
    }

    /***********************************************************************************************
     * IMAGE MANAGEMENT
     *
     *
     *  loading from gallery for now ~~
     */
    /**
     * method 'loadImages'
     *
     * context-> onCreate()
     *
     * places all of the image filenames into a Map for access at any time
     */
    public void findImages(){
        //mediaStorageDir = new File(Environment.getExternalStoragePublicDirectory(
        //        Environment.DIRECTORY_PICTURES), "Boomerang");
        //Log.d(TAG,"listing files from internal storage...");
        //File[] files = getFilesDir().listFiles();

        //for(int i = 0; i < files.length; i++) {
        //    theImages.put(i,files[i].getAbsolutePath());
       // }

        //if (theImages.size() == 0) {
            //ImageRequestService.startActionRequestImages(this, 10, null);
       // } else {
        //    TextView textView = (TextView) findViewById(R.id.statusTextView);
        //    textView.setVisibility(View.INVISIBLE);
       // }


    }

    /**
     * method 'loadBitmap'
     *
     * @param fileName fileName of th
     * @param imageView location to place the new bitmap
     */
    /*
    public void loadBitmap(String fileName, ImageView imageView) {
        if (cancelPotentialWork(fileName, imageView)) {
            final BitmapWorkerTask task = new BitmapWorkerTask(imageView);
            final AsyncDrawable asyncDrawable =
                    new AsyncDrawable(getResources(), mPlaceHolderBitmap, task);
            imageView.setImageDrawable(asyncDrawable);
            task.execute(fileName);
        }
    }*/


    /**
     * static method 'decodeSampledBitmapFromFile'
     *
     * @param filePath the filePath of the image to be converted
     * @return bitmap that has successfully decoded and sized
     *
     *
     * decodes the bitmap given the filePath. This method is executed during an
     * asynchronous method, in order to properly run in the background
     * ideally, the image should already be scaled and sized properly by the server
     *
     */
    public static Bitmap decodeSampledBitmapFromFile(String filePath) {
        Log.d(TAG,"entering decodeSampledBitmapFromFile...");


        // First decode with inJustDecodeBounds=true to check dimensions
        final BitmapFactory.Options options = new BitmapFactory.Options();
        //only decode boundaries, then check
        //options.inJustDecodeBounds = true;
        //BitmapFactory.decodeFile(filePath, options);
        //options.inSampleSize = resizeImage(options, reqWidth, reqHeight);

        //now decode for real
        ///options.inJustDecodeBounds = false;
        /**
         * A switching mechanism, assumes we load the first bitmap first, SWITCH
         */
        /*
        if (currentBitmapToLoad) {
            options.inBitmap = localCachedFirst.get(); //send the first bitmap out
            localCachedFirst = new WeakReference<>(localCachedSecond.get()); //the second now is the first
            currentBitmapToLoad = false;
        } else {
            options.inBitmap = localCachedSecond.get();  //the send the second out
            currentBitmapToLoad = true;
        }*/

        Log.d(TAG, "bitmap dimensons: height= " + options.outHeight + "width = " + options.outWidth); //todo remove this
        return BitmapFactory.decodeFile(imageDir + filePath, options);
    }

    /**
     * static method 'resizeImage'
     *
     * @param options options object for the bitmap
     * @param reqHeight height to be scaled to
     * @param reqWidth width to be scaled to
     * @return the size of the bitmap scaled
     *
     * scales the bitmap to the proper size based on the required width and height provided
     */

    public static int resizeImage(BitmapFactory.Options options, int reqWidth, int reqHeight) {
        final String TAG = "resizeImage";


        // Raw height and width of image
        final int height = options.outHeight;
        final int width = options.outWidth;
        int inSampleSize = 0;

        Log.d(TAG,"current width is + " + width + " and height is " + height);
        Log.d(TAG,"reqWidth is " + reqWidth + " and height is " + reqHeight);


        if (height > reqHeight || width > reqWidth) {
            if (inSampleSize == 0) {
                inSampleSize = 2;
            }

            final int halfHeight = height / 2;
            final int halfWidth = width / 2;

            // Calculate the largest inSampleSize value that is a power of 2 and keeps both
            // height and width larger than the requested height and width.
            while ((halfHeight / inSampleSize) > reqHeight
                    && (halfWidth / inSampleSize) > reqWidth) {
                inSampleSize *= 2;
            }
        }

        Log.d(TAG, "resizeImage sample size is: " + inSampleSize);

        return inSampleSize;
    }

    /**
     * static class 'rotateBitmap'
     *
     * @param source bitmap to rotate
     * @param angle angle to rotate
     * @return rotated bitmap
     *
     * rotates the bitmap center point
     *
     * *stackoverflow @@ untested*
     */
    public static Bitmap rotateBitmap(Bitmap source, float angle)
    {
        Matrix matrix = new Matrix();
        matrix.postRotate(angle);
        return Bitmap.createBitmap(source, 0, 0, source.getWidth(), source.getHeight(), matrix, true);
    }

    /***
     * static method 'cancelPotentialWork'
     *
     * @param data file name of the image to be compared
     * @param imageView imageView in question
     * @return the status of the task
     *
     * checks to see if the imageView is currently involved with any other process
     * and if so, cancels
     *
     * *ripped from google*
     */
    public static boolean cancelPotentialWork(String data, ImageView imageView) {
        final BitmapWorkerTask bitmapWorkerTask = getBitmapWorkerTask(imageView); //todo learn this

        if (bitmapWorkerTask != null) {
            final String bitmapData = bitmapWorkerTask.data;
            Log.d(TAG, bitmapData + "compared to " + data);

            // If bitmapData is not yet set or it differs from the new data
            if (bitmapData == null || !bitmapData.equals(data)) {
                // Cancel previous task
                bitmapWorkerTask.cancel(true);
            } else {
                // The same work is already in progress
                return false;
            }
        }

        Log.d(TAG, "cancelPotentialWork found that the imageView is missing or busy");

        // No task associated with the ImageView, or an existing task was cancelled
        return true;
    }

    /**
     * static class 'getBitmapWorkerTask'
     *
     * @param imageView imageView in question
     * @return null
     *
     * gets the drawable
     *
     * *ripped from google*
     */
    private static BitmapWorkerTask getBitmapWorkerTask(ImageView imageView) {
        if (imageView != null) {
            final Drawable drawable = imageView.getDrawable();
              if (drawable instanceof AsyncDrawable) {
                Log.d(TAG, "getBitmapWorkerTask found an AsyncDrawable");

                final AsyncDrawable asyncDrawable = (AsyncDrawable) drawable;
                return asyncDrawable.getBitmapWorkerTask();
              }
        }

        Log.d(TAG, "getBitmapWorkerTask> AsyncDrawable was NOT found");

        return null;
    }

    /**
     * class 'AsyncDrawable'
     *
     * creates an AsyncDrawable
     * *ripped from google*
     */
    static class AsyncDrawable extends BitmapDrawable {
        private final WeakReference<BitmapWorkerTask> bitmapWorkerTaskReference;

        public AsyncDrawable(Resources res, Bitmap bitmap,
                             BitmapWorkerTask bitmapWorkerTask) {
            super(res, bitmap);
            bitmapWorkerTaskReference =
                    new WeakReference<BitmapWorkerTask>(bitmapWorkerTask);
        }

        public BitmapWorkerTask getBitmapWorkerTask() {
            return bitmapWorkerTaskReference.get();
        }
    }


    /**
     * class 'BitmapWorkerTask'
     *
     * passed a String and returns a Bitmap
     *
     * decodes Bitmap from a filename in a separate thread for performance
     *
     */
    static class BitmapWorkerTask extends AsyncTask<String, Void, Bitmap> {
        private final WeakReference<ImageView> imageViewReference;
        private String data = null;
        private final String TAG = "BitMapWorkerTask: ";


        //data pulled in from loadImages
        public BitmapWorkerTask(ImageView imageView) {
            // Use a WeakReference to ensure the ImageView can be garbage collected
            imageViewReference = new WeakReference<>(imageView);

            Log.d(TAG,"Pre-Execute started");
        }

        // Decode image in background.
        @Override
        protected Bitmap doInBackground(String[] params) {
            data = params[0];
            Log.d(TAG, "image loaded, file name is: " + data);
            return decodeSampledBitmapFromFile(data);
        }

        // Once complete, see if ImageView is still around and set bitmap.
        @Override
        protected void onPostExecute(Bitmap bitmap) {

            if (isCancelled()) {
                bitmap = null;
            }

            if (imageViewReference != null && bitmap != null) {
                final ImageView imageView = imageViewReference.get();
                if (imageView != null) {
                    imageView.setImageBitmap(bitmap);
                }
                else
                {
                    Log.d(TAG,"ImageView was null");
                }
            }
        }
    }

    /***********************************************************************************************
     * SERVICE COMMUNICATION
     */
    /**
     * method 'setUpServiceCommunication'
     *
     * registers the broadcast receiver in the main UI thread
     * this will recieve updates from "handleActionSendImages"
     */
    public void setUpServiceCommunication() {

        /*IntentFilter mStatusIntentFilter = new IntentFilter(
                Constants.IMAGE_SENDING_RESULT);

        ReceiverImageSendResult mReceiverImageSendResult =
                new ReceiverImageSendResult();
        // Registers the DownloadStateReceiver and its intent filters
        LocalBroadcastManager.getInstance(this).registerReceiver(
                mReceiverImageSendResult,
                mStatusIntentFilter);
        mReceiverImageSendResult.giveActivity(this);*/
    }


    /**
     * tags for replyHandler's various tasks
     */
    static final int MSG_IMAGE_STORED = 0;

    static final int MSG_IMAGE_SENT= 1;

    static final int MSG_DATABASE_CLEARED= 2;

    /**
     * class 'replyHandler'
     *
     * handles responses from the service
     */
    static class replyHandler extends Handler {

        WeakReference<MainActivity> activity;

        public Handler setParent(MainActivity parent) {
            activity = new WeakReference<>(parent);

            return this;
        }

        public void handleMessage(Message msg) {
            Log.d(TAG,"enter handleMessage");
            int respCode = msg.what;

            int result;
            int distance;

            switch (respCode) {
                case MSG_IMAGE_STORED:
                    result = msg.arg1;
                    Toast.makeText(activity.get(),"reply from service received " + result,Toast.LENGTH_LONG).show();

                    //File[] toLoad = new File[1];
                    //toLoad[0] = new File("IMG_"+msg.arg1+".jpg");
                    if (mPager.getCurrentItem() <= CAMERA_LIST_POSITION) {//ensure localFrament exists.
                      LocalFragment.getInstance()
                              .loadIncomingImageFromServer(msg.arg1, msg.getData().getDouble("distance"));
                    }
                    break;

                case MSG_IMAGE_SENT:
                    result = msg.arg1;
                    Toast.makeText(activity.get(),"Image size to be sent is: " + result/1024 + "kB",Toast.LENGTH_LONG).show();
                    break;

                case MSG_DATABASE_CLEARED:
                    Toast.makeText(activity.get(),"entire database cleared",Toast.LENGTH_LONG).show();
                    break;
            }

            Log.d(TAG,"exit handleMessage");
        }
    }


    /**
     * static class 'ReceiverDownloadState'
     *
     * BroadcastReceiver to receive download status updates from the IRS
     */
    public static class ReceiverDownloadState extends BroadcastReceiver
    {
        MainActivity mainActivity;

        private String TAG = "RecieverDownloadState";

        @Override
        public void onReceive(Context context, Intent intent) {

            Log.d(TAG,"broadcast recieved!");

            int receivedValue = intent.getIntExtra(Constants.EXTENDED_DATA_STATUS,0);
            Log.d(TAG,"received value is: " + receivedValue);

            TextView text = (TextView) mainActivity.findViewById(R.id.statusTextView);

            if (text == null) {//textview was null, return to prevent error
                Log.d(TAG, "feedback view not found, exiting");
                return;
            }


            switch (receivedValue) {
                case 0:
                case 200:
                    Toast.makeText(mainActivity,"Success!... ", Toast.LENGTH_LONG).show();
                    break;
                case 1:
                    Toast.makeText(mainActivity,"Uncaught generic exception...", Toast.LENGTH_LONG).show();
                    break;
                case 2:
                    Toast.makeText(mainActivity,"Uncaught IOException... ", Toast.LENGTH_LONG).show();
                    break;
            }


        }

        public void giveActivity(MainActivity mainActivity) { //todo is this bad?
            this.mainActivity = mainActivity;
        }
    }


    /**
     * static class 'ReceiverImageSendResult'
     *
     * BroadcastReceiver to receiver imageSendingResults from the IRS
     */
    public static class ReceiverImageSendResult extends BroadcastReceiver
    {
        MainActivity mainActivity;

        private String TAG = "RecieverDownloadState";

        /**
         * method 'onReceive'
         *
         * called when a broadcast with this receiver's filter is sent
         * handles the data accordingly, updating the UI
         *
         * @param context environment in which the service exists
         * @param intent data that was sent
         */
        @Override
        public void onReceive(Context context, Intent intent) {
            Log.d(TAG,"broadcast recieved!");

            int receivedValue = intent.getIntExtra(Constants.EXTENDED_DATA_STATUS,0);
            Log.d(TAG,"received value is: " + receivedValue);

            TextView text = (TextView) mainActivity.findViewById(R.id.statusTextView);

            if (text == null) {//textview was null, return to prevent error
                Log.d(TAG, "feedback view not found, exiting");
                return;
            }


            switch (receivedValue) {
                case 0:
                case 200:
                    Toast.makeText(mainActivity,"Success!... ", Toast.LENGTH_LONG).show();
                    break;
                case 1:
                    Toast.makeText(mainActivity,"Uncaught generic exception...", Toast.LENGTH_LONG).show();
                    break;
                case 2:
                    Toast.makeText(mainActivity,"Uncaught IOException... ", Toast.LENGTH_LONG).show();
                    break;
                default:
                    Toast.makeText(mainActivity,"wat... ", Toast.LENGTH_LONG).show();

            }


        }

        public void giveActivity(MainActivity mainActivity) { //todo is this bad?
            this.mainActivity = mainActivity;
        }
    }

    /**
     *
     */
    private ServiceConnection mConnection = new ServiceConnection() {
        public void onServiceConnected(ComponentName className, IBinder service) {
            // This is called when the connection with the service has been
            // established, giving us the object we can use to
            // interact with the service.  We are communicating with the
            // service using a Messenger, so here we get a client-side
            // representation of that from the raw IBinder object.
            Log.d(TAG,"binding to service...");

            mService = new Messenger(service);
            isBound = true;
        }

        public void onServiceDisconnected(ComponentName className) {
            // This is called when the connection with the service has been
            // unexpectedly disconnected -- that is, its process crashed.
            Log.d(TAG,"unbinding from service...");

            mService = null;
            isBound = false;
        }
    };

    /**
     * method 'onImageSaved'
     *
     * notifys the mainActivity that an image was just saved, so that the activity
     * can notify the service to send this image to the server
     *
     * @param filePath the file path of the image saved
     */
    @Override
    public void onImageSaved(String filePath) {
        Log.d(TAG,"sending message to send Image");
        if (isBound) {
            Log.d(TAG, "sending message containing filepath to load...");
            //Message msg1 = Message.obtain(null, ImageRequestService.MSG_BUILD_CLIENT, 0, 0);
            Message msg = Message.obtain(null, ImageRequestService.MSG_SEND_IMAGE,0,0);

            Bundle b = new Bundle(1);
            b.putString(Constants.IMAGE_FILEPATH, filePath);
            msg.setData(b);
            try {
                msg.replyTo = messageHandler;
                mService.send(msg);
            } catch (RemoteException e) {
                e.printStackTrace();
            }

        }
    }

    /**
     * callback from {@link jokrapp.boomerang.CameraFragment.OnCameraFragmentInteractionListener}
     */
    @Override
    public void toggleScrolling() {
        if (mPager.isPagingEnabled()) {
            mPager.setPagingEnabled(false);
        } else {
            mPager.setPagingEnabled(true);
        }
    }
}